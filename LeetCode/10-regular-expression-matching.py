###############################################################################################
# 可以归类为线性dp，但属性不同于一般的最大最小数量，而是bool
# 状态转移比较难想；而且此题的dp[i]并不只是和上一层dp[i-1]有关，滚动数组优化会有问题
###########
# 时间复杂度：O(nm)，两个循环
# 空间复杂度：O(nm)
###############################################################################################
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        N, lens, lenp = 35, len(s), len(p)
        dp = [[0]*N for _ in range(N)] # dp[i][j]: s前i个和p前j个能否匹配(i,j >= 1)
        dp[0][0] = 1 # 都为前0个是可以匹配的

        for i in range(lens+1):
            for j in range(1, lenp+1): # 当j为0，就没法匹配i>=1的情况了
                if p[j-1] == '*':
                    dp[i][j] = dp[i][j-2] # 不论能不能匹配，先不匹配
                    if i>0 and (s[i-1] == p[j-2] or p[j-2] == '.'): # s的第i个和p中*的前一个可以匹配
                        dp[i][j] |= dp[i-1][j] # 再和i的前一个匹配试试
                else:
                    if i>0 and (s[i-1] == p[j-1] or p[j-1] == '.'): # 若s第i个和p第j个可以匹配(i,j>=1)
                        dp[i][j] = dp[i-1][j-1] # 只需要看前面匹不匹配
        return bool(dp[lens][lenp])