###############################################################################################
# 前序遍历一次即可，只不过需要注意要在递归左儿子前记录下自己的右儿子，不然会被覆盖
###########
# 时间复杂度：O(n)，每个节点遍历一次
# 空间复杂度：O(n)，最坏情况可能是一根链
###############################################################################################
class Solution:
    def flatten(self, root: TreeNode) -> None:
        last = 0
        def dfs(u, level):
            nonlocal last
            if u:
                if last: # 如果不是第一个节点
                    last.left = None # 上一个的左置None
                    last.right = u # 上一个的右就是自己
                last = u # 将上一个更新为自己，以便下一个使用
                right = u.right # 先提前记录当前节点的右，以防被覆盖
                dfs(u.left, level+1)
                dfs(right, level+1)
        dfs(root, 1)