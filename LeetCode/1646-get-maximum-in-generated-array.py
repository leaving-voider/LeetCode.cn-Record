###############################################################################################
# 记忆化dp，超级快; 且没有像官方那样直接模拟，应该是实际耗时会更少一点，毕竟只算了奇数和必须的偶数
# 而官方的模拟是每个数都算了
###########
# 时间复杂度：O(n)
# 空间复杂度：O(n)
###############################################################################################
class Solution:
    def getMaximumGenerated(self, n: int) -> int:
        # 1 2 4 8 16 32 64 一样
        # 3 = 1 2，5 = 2 3，6 = 3，7 = 3 4，8 = 4，9 = 4 5，10 = 5，11 = 5 6，13 = 6 7 不看偶数
        # 3 = 1 1，5 = 1 1 1，7 = 1 1 1，9 = 1 1 1 1，11 = 1 1 1 1 1 1 1，13 = 1 1 1 1 1 1 1，15 = 7 8 = 3 4 4 = 1 2 2 2 = 1 1 1 1
        # 所以，经分析，就遍历一次得了，只看奇数
        if not n:
            return 0
        dp = [0]*(n+1)
        def dfs(x):
            if x == 1:
                return 1
            if dp[x] != 0:
                return dp[x]
            if x % 2:
                dp[x] += dfs(x//2) + dfs(x//2+1)
            else:
                dp[x] += dfs(x//2)
            return dp[x]
        return max([dfs(per) for per in range(1, n+1, 2)])