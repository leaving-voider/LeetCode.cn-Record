###############################################################################################
# 预处理每个位置可能的数，再dfs
###########
# 时间复杂度：O(n!)，因为预处理限制了可选数的数量，时间复杂度不到n!，可接受
# 空间复杂度：O(n^2)
###############################################################################################
class Solution:
    def countArrangement(self, n: int) -> int:
        def findok(x):
            ret = [1]
            for i in range(2, n+1):
                if x % i == 0 or i % x == 0: # 可能的数为小于n的x的约数和倍数
                    ret.append(i)
            return ret
        ok = [[]]
        for i in range(1, n+1):
            ok.append(findok(i))
        res, st = 0, set()
        def dfs(u):
            nonlocal res
            if u == n + 1:
                res += 1
                return
            for per in ok[u]:
                if per not in st:
                    st.add(per)
                    dfs(u+1)
                    st.remove(per)
        dfs(1)
        return res


###############################################################################################
# 状态压缩dp
###########
# 时间复杂度：O(n*2^n), 计算每个状态
# 空间复杂度：O(2^n), dp数组消耗
###############################################################################################
class Solution:
    def countArrangement(self, n: int) -> int:
        dp = [0]*(1<<n) # dp[i]: 状态为i的合法排列方案数；比如i=6即0110，选取了2和3, 2和3在前两个位置任意排列的合法方案数
        dp[0] = 1 # 当状态为0，即任何一个数都没选，此时满足题目个给的两个条件之一，因此方案为1
        for i in range(1, 1<<n): # 遍历每个状态
            num = bin(i).count("1")
            for j in range(n):
                if 1<<j & i and (num % (j + 1) == 0 or (j+1) % num == 0): # 第j+1个位置上为1表示选取了j+1这个数，这样才能转移；并且第num个位置和j+1必须满足两个条件之一
                    dp[i] += dp[i-(1<<j)] # 从减去这个数的地方转移而来，其实这里异或也可以
        return dp[(1<<n)-1] # 返回全状态的方案数