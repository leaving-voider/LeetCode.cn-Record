###############################################################################################
# 暴搜，超时
###########
# 时间复杂度：O(2^(m+n)), 一共需要m+n步，每步都是两种选择，此题m+n最大200，2^200 ≈ 10^60 太吓人了...
# 空间复杂度：O(1)
###############################################################################################
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        res = 0
        def dfs(i, j):
            nonlocal res
            if i == m and j == n:
                res += 1
                return
            
            if i + 1 <= m:
                dfs(i+1, j)
            if j + 1 <= n:
                dfs(i, j+1)
        
        dfs(1,1)
        return res


###############################################################################################
# 简单动规
###########
# 时间复杂度：O(m*n)
# 空间复杂度：O(m*n)
###############################################################################################
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        N = 110
        dp = [[1]*N for _ in range(N)] # dp[i][j]: 走到第i,j位置有多少种走法，顺带初始化上边和左边全部为1，因为只能往下或右走，所以左、上边的都只能直着走
        
        for i in range(2, m+1):
            for j in range(2, n+1):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]

        return dp[m][n]

# 滚动数组
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        N = 110
        dp = [1]*N # dp[j]: 走到第m, j位置有多少种走法
        
        for i in range(2, m+1):
            for j in range(2, n+1):
                dp[j] += dp[j-1]

        return dp[n]

###############################################################################################
# 数学，服，甚至感觉高中讲过
# 因为总共移动次数是m+n-2次，我们只需要选m-1次作为往下即可，组合数学来计算有多少种选法，即(m+n-2)!/((m-1)!*(n-1)!)
# 感觉又可以转化为背包问题
###########
# 时间复杂度：O(min(m,n))，计算的时候，把大的那块阶乘抵消了，算小的
# 空间复杂度：O(1)
###############################################################################################
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        res = 1
        for i in range(n, m+n-1):
            res *= i/(i-n+1)
        return int(res+1) if res > int(res)+0.5 else int(res) # 最后这个是因为...计算的误差需要判断下，比如多0.000001或者少了0.000001


###############################################################################################
# 这次等价为01背包问题，即m+n-2步里面，选m-1个作为下，其他的就是右
###########
# 时间复杂度：O((m+n)*m)，虽然比普通动规理论复杂度高，但执行速度差不太多
# 空间复杂度：O(m+n)
###############################################################################################
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 等价为背包问题，m+n-2个物品，每个价值1
        dp = [[0]*m for _ in range(m+n-1)] # dp[i][j]，前i个选，使得价值恰好为j的方案个数，最终要的就是价值为m-1
        for i in range(m+n-1):
            dp[i][0] = 1 # 前i个选，使得价值为0的方案数，就是什么都不选
        for i in range(1, m+n-1):
            for j in range(1, m):
                # dp[i-1][j]即不选， dp[i-1][j-1]即选
                dp[i][j] = dp[i-1][j] + dp[i-1][j-1]
        return dp[m+n-2][m-1]

# 同样滚动数组
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [0]*m # dp[i]，前m+n-2个选，使得价值恰好为j的方案个数
        dp[0] = 1
        for i in range(1, m+n-1):
            for j in range(m-1, 0, -1):
                dp[j] += dp[j-1]
        return dp[m-1]